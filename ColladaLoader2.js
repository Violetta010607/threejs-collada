// Generated by CoffeeScript 1.3.3
var ColladaAsset, ColladaColorOrTexture, ColladaEffect, ColladaEffectSampler, ColladaEffectSurface, ColladaEffectTechnique, ColladaFile, ColladaFxLink, ColladaGeometry, ColladaImage, ColladaInput, ColladaLoader2, ColladaMaterial, ColladaSidLink, ColladaSource, ColladaUrlLink;

ColladaUrlLink = (function() {

  function ColladaUrlLink(url, type) {
    this.url = url.replace(/^#/, "");
    this.object = null;
    this.type = type;
  }

  ColladaUrlLink.prototype.resolve = function(file, log) {
    this.object = file.dae.ids[this.url];
    if (!(this.object != null)) {
      log("Could not resolve URL #" + this.url, ColladaLoader2.messageError);
      return false;
    }
    if ((this.type != null) && !this.object instanceof this.type) {
      this.object = null;
      log("URL #" + this.url + " is not linked to a " + type, ColladaLoader2.messageError);
      return false;
    }
    return true;
  };

  return ColladaUrlLink;

})();

ColladaFxLink = (function() {

  function ColladaFxLink(url, scope, type) {
    this.url = url;
    this.scope = scope;
    this.object = null;
    this.type = type;
  }

  ColladaFxLink.prototype.resolve = function(file, log) {
    var scope;
    scope = this.scope;
    this.object = scope.sids[this.url];
    while (!(this.object != null) && (scope != null)) {
      scope = scope.parentFxScope;
      this.object = scope.sids[this.url];
    }
    if (!(this.object != null)) {
      log("Could not resolve FX parameter #" + this.url, ColladaLoader2.messageError);
      return false;
    }
    if ((this.type != null) && !this.object instanceof this.type) {
      this.object = null;
      log("FX parameter #" + this.url + " is not linked to a " + type, ColladaLoader2.messageError);
      return false;
    }
    return true;
  };

  return ColladaFxLink;

})();

ColladaSidLink = (function() {

  function ColladaSidLink(parentId, url, type) {
    var arrIndices, arrSyntax, dotSyntax, index, lastSid, parts, _i, _len;
    this.url = url;
    this.object = null;
    this.type = type;
    this.id = null;
    this.sids = [];
    this.member = null;
    this.indices = null;
    this.dotSyntax = false;
    this.arrSyntax = false;
    parts = url.split("/");
    this.id = parts.shift();
    if (this.id === ".") {
      this.id = parentId;
    }
    while (parts.length > 1) {
      this.sids.push(parts.shift());
    }
    if (parts.length > 0) {
      lastSid = parts[0];
      dotSyntax = lastSid.indexOf(".") >= 0;
      arrSyntax = astSid.indexOf("(") >= 0;
      if (dotSyntax) {
        parts = sid.split(".");
        this.sids.push(parts.shift());
        this.member = parts.shift();
        this.dotSyntax = true;
      } else if (arrSyntax) {
        arrIndices = lastSid.split("(");
        this.sids.push(arrIndices.shift());
        this.indices = [];
        for (_i = 0, _len = arrIndices.length; _i < _len; _i++) {
          index = arrIndices[_i];
          this.indices.push(parseInt(index.replace(/\)/, "")));
        }
        this.arrSyntax = true;
      } else {
        this.sids.push(lastSid);
      }
    }
  }

  ColladaSidLink.prototype.resolve = function(file, log) {
    var sid, _i, _len, _ref;
    this.object = file.dae.ids[this.id];
    if (!(this.object != null)) {
      log("Could not resolve SID #" + this.url + ", missing base ID " + this.id, ColladaLoader2.messageError);
      return false;
    }
    _ref = this.sids;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      sid = _ref[_i];
      this.object = this.object.sids[sid];
      if (!(this.object != null)) {
        log("Could not resolve SID #" + this.url + ", missing SID part " + sid, ColladaLoader2.messageError);
        return false;
      }
    }
    return true;
  };

  return ColladaSidLink;

})();

ColladaFile = (function() {

  function ColladaFile() {
    this.url = null;
    this.baseUrl = null;
    this.dae = {};
    this.dae.ids = {};
    this.dae.libEffects = {};
    this.dae.libMaterials = {};
    this.dae.libGeometries = {};
    this.dae.libControllers = {};
    this.dae.libLights = {};
    this.dae.libImages = {};
    this.dae.libScenes = {};
    this.dae.libAnimations = {};
    this.dae.asset = new ColladaAsset();
  }

  ColladaFile.prototype.setUrl = function(url) {
    var parts, _ref;
    if (url != null) {
      this.url = url;
      parts = url.split("/");
      parts.pop();
      this.baseUrl = ((_ref = parts.length < 1) != null ? _ref : {
        ".": parts.join("/")
      }) + "/";
    } else {
      this.url = null;
      this.baseUrl = null;
    }
  };

  return ColladaFile;

})();

ColladaAsset = (function() {

  function ColladaAsset() {
    this.unit = 1;
    this.upAxis = "Z";
  }

  return ColladaAsset;

})();

ColladaImage = (function() {

  function ColladaImage() {
    this.id = null;
    this.init_from = null;
  }

  return ColladaImage;

})();

ColladaEffect = (function() {

  function ColladaEffect() {
    this.id = null;
    this.sids = {};
    this.technique = new ColladaEffectTechnique();
  }

  return ColladaEffect;

})();

ColladaEffectTechnique = (function() {

  function ColladaEffectTechnique() {
    this.sids = {};
    this.parentFxScope = null;
    this.shading = null;
    this.emission = new ColladaColorOrTexture(0xffffff);
    this.ambient = new ColladaColorOrTexture(0xffffff);
    this.diffuse = new ColladaColorOrTexture(0xffffff);
    this.specular = new ColladaColorOrTexture(0xffffff);
    this.shininess = new ColladaColorOrTexture(0xffffff);
    this.reflective = new ColladaColorOrTexture(0xffffff);
    this.transparent = new ColladaColorOrTexture(0xffffff);
    this.reflectivity = 1;
    this.transparency = 1;
    this.index_of_refraction = 1;
  }

  return ColladaEffectTechnique;

})();

ColladaEffectSurface = (function() {

  function ColladaEffectSurface() {
    this.sid = null;
    this.type = null;
    this.initFrom = null;
  }

  return ColladaEffectSurface;

})();

ColladaEffectSampler = (function() {

  function ColladaEffectSampler() {
    this.sid = null;
    this.surface = null;
    this.image = null;
  }

  return ColladaEffectSampler;

})();

ColladaColorOrTexture = (function() {

  function ColladaColorOrTexture(hex) {
    this.color = new THREE.Color(hex);
    this.texture_sampler = null;
    this.texcoord = null;
    this.opaque = null;
    this.bump = null;
  }

  return ColladaColorOrTexture;

})();

ColladaMaterial = (function() {

  function ColladaMaterial() {
    this.id = null;
    this.name = null;
    this.effect = null;
  }

  return ColladaMaterial;

})();

ColladaGeometry = (function() {

  function ColladaGeometry() {
    this.id = null;
    this.name = null;
    this.vertices = {};
    this.triangles = {};
    this.indices = null;
  }

  return ColladaGeometry;

})();

ColladaSource = (function() {

  function ColladaSource() {
    this.id = null;
    this.sourceId = null;
    this.count = null;
    this.stride = null;
    this.data = null;
    this.params = {};
  }

  return ColladaSource;

})();

ColladaInput = (function() {

  function ColladaInput() {
    this.semantic = null;
    this.source = null;
    this.offset = null;
    this.set = null;
  }

  return ColladaInput;

})();

ColladaLoader2 = (function() {

  ColladaLoader2.messageTrace = 0;

  ColladaLoader2.messageInfo = 1;

  ColladaLoader2.messageWarning = 2;

  ColladaLoader2.messageError = 3;

  ColladaLoader2.messageTypes = ["TRACE", "INFO", "WARNING", "ERROR"];

  function ColladaLoader2() {
    this.log = this.logConsole;
    this.readyCallback = null;
    this.progressCallback = null;
    this.file = null;
    this.upConversion = null;
    this.options = {
      centerGeometry: false,
      convertUpAxis: false,
      subdivideFaces: true,
      upAxis: "Y"
    };
  }

  ColladaLoader2.logConsole = function(msg, type) {
    console.log("ColladaLoader2 " + ColladaLoader2.messageTypes[type] + ": " + msg);
  };

  ColladaLoader2.prototype.setLog = function(logCallback) {
    this.log = logCallback || this.logConsole;
  };

  ColladaLoader2.prototype.load = function(url, readyCallback, progressCallback) {
    var length, req;
    this.readyCallback = readyCallback;
    length = 0;
    if (document.implementation && document.implementation.createDocument) {
      req = new XMLHttpRequest();
      if (req.overrideMimeType) {
        req.overrideMimeType("text/xml");
      }
      req.onreadystatechange = function() {
        if (req.readyState === 4) {
          if (req.status === 0 || req.status === 200) {
            if (req.responseXML) {
              return this.parse(req.responseXML, readyCallback, url);
            } else {
              return this.log("Empty or non-existing file " + url + ".", ColladaLoader2.messageError);
            }
          }
        } else if (req.readyState === 3) {
          if (progressCallback) {
            if (length === 0) {
              length = req.getResponseHeader("Content-Length");
            }
            return progressCallback({
              total: length,
              loaded: req.responseText.length
            });
          }
        }
      };
      req.open("GET", url, true);
      req.send(null);
    } else {
      this.log("Don't know how to parse XML!", ColladaLoader2.messageError);
    }
  };

  ColladaLoader2.prototype.parse = function(doc, readyCallback, url) {
    var result;
    this.readyCallback = readyCallback;
    this.file = new ColladaFile;
    this.file.setUrl(url);
    this._parseXml(doc);
    result = this.file;
    this.file = null;
    if (this.readyCallback) {
      this.readyCallback(result);
    }
    return result;
  };

  ColladaLoader2.prototype._reportUnexpectedChild = function(parent, child) {
    return this.log("Skipped unknown <" + parent + "> child <" + child + ">.", ColladaLoader2.messageWarning);
  };

  ColladaLoader2.prototype._parseXml = function(doc) {
    var child, colladaElement, _i, _len, _ref, _ref1, _ref2, _results;
    if (((_ref = doc.childNodes[0]) != null ? (_ref1 = _ref.nodeName) != null ? _ref1.toUpperCase() : void 0 : void 0) === "COLLADA") {
      colladaElement = doc.childNodes[0];
      _ref2 = colladaElement.childNodes;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        child = _ref2[_i];
        if (child.nodeType === 1) {
          _results.push(this._parseColladaChild(child));
        }
      }
      return _results;
    } else {
      return this.log("Can not parse document, top level element is not <COLLADA>.", ColladaLoader2.messageError);
    }
  };

  ColladaLoader2.prototype._getFirstChildByName = function(el, name) {
    var child, _i, _len, _ref;
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1 && child.nodeName === name) {
        return child;
      }
    }
    return null;
  };

  ColladaLoader2.prototype._parseColladaChild = function(el) {
    var child, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4;
    switch (el.nodeName) {
      case "asset":
        _ref = el.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.nodeType === 1) {
            this._parseAssetChild(child);
          }
        }
        break;
      case "library_effects":
        _ref1 = el.childNodes;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          child = _ref1[_j];
          if (child.nodeType === 1) {
            this._parseLibEffectChild(child);
          }
        }
        break;
      case "library_materials":
        _ref2 = el.childNodes;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          child = _ref2[_k];
          if (child.nodeType === 1) {
            this._parseLibMaterialChild(child);
          }
        }
        break;
      case "library_geometries":
        _ref3 = el.childNodes;
        for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
          child = _ref3[_l];
          if (child.nodeType === 1) {
            this._parseLibGeometryChild(child);
          }
        }
        break;
      case "library_images":
        _ref4 = el.childNodes;
        for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
          child = _ref4[_m];
          if (child.nodeType === 1) {
            this._parseLibImageChild(child);
          }
        }
        break;
      default:
        this._reportUnexpectedChild("COLLADA", el.nodeName);
    }
  };

  ColladaLoader2.prototype._parseAssetChild = function(el) {
    var meter;
    switch (el.nodeName) {
      case "unit":
        meter = el.getAttribute("meter");
        if (meter != null) {
          this.file.dae.asset.unit = parseFloat(meter);
        }
        break;
      case "up_axis":
        this.file.dae.asset.upAxis = el.textContent.toUpperCase().charAt(0);
        this.upConversion = this._getUpConversion(this.file.dae.asset.upAxis, this.options.upAxis);
        break;
      case "contributor":
      case "created":
      case "modified":
        break;
      default:
        this._reportUnexpectedChild("asset", el.nodeName);
    }
  };

  ColladaLoader2.prototype._parseLibEffectChild = function(el) {
    var child, effect, _i, _len, _ref;
    switch (el.nodeName) {
      case "effect":
        effect = new ColladaEffect;
        effect.id = el.getAttribute("id");
        this._addUrlTarget(effect, "libEffects");
        _ref = el.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.nodeType === 1) {
            this._parseEffectChild(effect, child);
          }
        }
        break;
      default:
        this._reportUnexpectedChild("library_effects", el.nodeName);
    }
  };

  ColladaLoader2.prototype._parseEffectChild = function(effect, el) {
    var child, _i, _len, _ref, _results;
    switch (el.nodeName) {
      case "profile_COMMON":
        _ref = el.childNodes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.nodeType === 1) {
            _results.push(this._parseEffectProfileCommonChild(effect, child));
          }
        }
        return _results;
        break;
      case "profile":
        return this.log("Skipped non-common effect profile for effect " + effect.id + ".", ColladaLoader2.messageWarning);
      default:
        return this._reportUnexpectedChild("effect", el.nodeName);
    }
  };

  ColladaLoader2.prototype._parseEffectProfileCommonChild = function(effect, el) {
    var child, sid, _i, _j, _len, _len1, _ref, _ref1;
    sid = el.getAttribute("sid");
    switch (el.nodeName) {
      case "newparam":
        _ref = el.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.nodeType === 1) {
            this._parseEffectNewparamChild(effect, sid, child);
          }
        }
        break;
      case "technique":
        _ref1 = el.childNodes;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          child = _ref1[_j];
          if (child.nodeType === 1) {
            this._parseEffectTechniqueChild(effect, sid, child);
          }
        }
        break;
      default:
        this._reportUnexpectedChild("profile_COMMON", el.nodeName);
    }
  };

  ColladaLoader2.prototype._parseEffectNewparamChild = function(scope, sid, el) {
    var child, sampler, surface, _i, _j, _len, _len1, _ref, _ref1;
    switch (el.nodeName) {
      case "surface":
        surface = new ColladaEffectSurface;
        surface.type = el.getAttribute("type");
        surface.sid = sid;
        this._addFxTarget(surface, scope);
        _ref = el.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.nodeType === 1) {
            this._parseEffectSurfaceChild(scope, surface, sid, child);
          }
        }
        break;
      case "sampler2D":
        sampler = new ColladaEffectSampler;
        sampler.sid = sid;
        this._addFxTarget(sampler, scope);
        _ref1 = el.childNodes;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          child = _ref1[_j];
          if (child.nodeType === 1) {
            this._parseEffectSamplerChild(scope, sampler, sid, child);
          }
        }
        break;
      default:
        this._reportUnexpectedChild("newparam", el.nodeName);
    }
  };

  ColladaLoader2.prototype._parseEffectSurfaceChild = function(scope, surface, sid, el) {
    switch (el.nodeName) {
      case "init_from":
        surface.initFrom = new ColladaUrlLink(el.textContent, ColladaImage);
        break;
      default:
        this._reportUnexpectedChild("surface", el.nodeName);
    }
  };

  ColladaLoader2.prototype._parseEffectSamplerChild = function(scope, sampler, sid, el) {
    switch (el.nodeName) {
      case "source":
        sampler.surface = new ColladaFxLink(el.textContent, scope, ColladaEffectSurface);
        break;
      case "instance_image":
        sampler.image = new ColladaUrlLink(el.getAttribute("url"), ColladaImage);
        break;
      default:
        this._reportUnexpectedChild("sampler*", el.nodeName);
    }
  };

  ColladaLoader2.prototype._parseEffectTechniqueChild = function(effect, sid, el) {
    var child, _i, _j, _len, _len1, _ref, _ref1;
    switch (el.nodeName) {
      case "blinn":
      case "phong":
      case "lambert":
      case "constant":
        effect.technique.shading = el.nodeName;
        _ref = el.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.nodeType === 1) {
            this._parseTechniqueParam(effect, "", child);
          }
        }
        break;
      case "extra":
        _ref1 = el.childNodes;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          child = _ref1[_j];
          if (child.nodeType === 1) {
            this._parseTechniqueExtraChild(effect, "", child);
          }
        }
        break;
      default:
        this._reportUnexpectedChild("technique", el.nodeName);
    }
  };

  ColladaLoader2.prototype._parseTechniqueParam = function(technique, profile, el) {
    var child, firstChild, _i, _len, _ref;
    firstChild = el.childNodes[1];
    switch (el.nodeName) {
      case "newparam":
        _ref = el.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.nodeType === 1) {
            this._parseEffectNewparamChild(technique, sid, child);
          }
        }
        break;
      case "emission":
      case "ambient":
      case "diffuse":
      case "specular":
      case "reflective":
        this._parseEffectColorOrTexture(technique, el.nodeName, firstChild);
        break;
      case "shininess":
      case "reflectivity":
      case "transparency":
      case "index_of_refraction":
        technique[el.nodeName] = parseFloat(firstChild.textContent);
        break;
      case "transparent":
        this._parseEffectColorOrTexture(technique, "transparent", firstChild);
        technique.transparent.opaque = firstChild.getAttribute("opaque");
        break;
      case "bump":
        this._parseEffectColorOrTexture(technique, "bump", firstChild);
        technique.bump.bumptype = firstChild.getAttribute("bumptype");
        break;
      default:
        this.log("Skipped unknown technique shading property " + el.nodeName + ".", ColladaLoader2.messageInfo);
    }
  };

  ColladaLoader2.prototype._parseTechniqueExtraChild = function(effect, profile, el) {
    var child, _i, _len, _ref;
    switch (el.nodeName) {
      case "technique":
        profile = el.getAttribute("profile");
        _ref = el.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.nodeType === 1) {
            this._parseTechniqueParam(effect, profile, child);
          }
        }
        break;
      default:
        this._reportUnexpectedChild("technique/extra", el.nodeName);
    }
  };

  ColladaLoader2.prototype._parseEffectColorOrTexture = function(technique, name, el) {
    var colorOrTexture, rgba;
    colorOrTexture = technique[name];
    if (!(colorOrTexture != null)) {
      colorOrTexture = new ColladaColorOrTexture(0xffffff);
      technique[name] = colorOrTexture;
    }
    switch (el.nodeName) {
      case "color":
        rgba = this._strToFloats(el.textContent);
        colorOrTexture.color.setRGB(rgba[0], rgba[1], rgba[2]);
        return colorOrTexture.color.a = rgba[3];
      case "texture":
        colorOrTexture.texture_sampler = new ColladaFxLink(el.getAttribute("texture"), technique, ColladaEffectSampler);
        return colorOrTexture.texcoord = el.getAttribute("texcoord");
      default:
        return this._reportUnexpectedChild("_color_or_texture_type", el.nodeName);
    }
  };

  ColladaLoader2.prototype._parseLibMaterialChild = function(el) {
    var child, material, _i, _len, _ref;
    switch (el.nodeName) {
      case "material":
        material = new ColladaMaterial;
        material.id = el.getAttribute("id");
        material.name = el.getAttribute("name");
        this._addUrlTarget(material, "libMaterials");
        _ref = el.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.nodeType === 1) {
            this._parseMaterialChild(material, child);
          }
        }
        break;
      default:
        this._reportUnexpectedChild("library_materials", el.nodeName);
    }
  };

  ColladaLoader2.prototype._parseMaterialChild = function(material, el) {
    switch (el.nodeName) {
      case "instance_effect":
        material.effect = new ColladaUrlLink(el.getAttribute("url"), ColladaEffect);
        break;
      default:
        this._reportUnexpectedChild("material", el.nodeName);
    }
  };

  ColladaLoader2.prototype._parseLibGeometryChild = function(el) {
    var child, geometry, _i, _len, _ref;
    switch (el.nodeName) {
      case "geometry":
        geometry = new ColladaGeometry();
        geometry.id = el.getAttribute("id");
        geometry.name = el.getAttribute("name");
        this._addUrlTarget(geometry, "libGeometries");
        _ref = el.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.nodeType === 1) {
            this._parseGeometryChild(geometry, child);
          }
        }
        break;
      default:
        this._reportUnexpectedChild("library_geometries", el.nodeName);
    }
  };

  ColladaLoader2.prototype._parseGeometryChild = function(geometry, el) {
    var child, _i, _len, _ref;
    switch (el.nodeName) {
      case "mesh":
        _ref = el.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.nodeType === 1) {
            this._parseMeshChild(geometry, child);
          }
        }
        break;
      default:
        this._reportUnexpectedChild("library_geometries", el.nodeName);
    }
  };

  ColladaLoader2.prototype._parseMeshChild = function(geometry, el) {
    var child, id, source, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    switch (el.nodeName) {
      case "source":
        id = el.getAttribute("id");
        source = new ColladaSource;
        source.id = id;
        this._addUrlTarget(source);
        _ref = el.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.nodeType === 1) {
            this._parseSourceChild(source, child);
          }
        }
        break;
      case "vertices":
        _ref1 = el.childNodes;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          child = _ref1[_j];
          if (child.nodeType === 1) {
            this._parseVerticesChild(geometry, child);
          }
        }
        break;
      case "triangles":
        _ref2 = el.childNodes;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          child = _ref2[_k];
          if (child.nodeType === 1) {
            this._parseTrianglesChild(geometry, child);
          }
        }
        break;
      case "polygons":
      case "polylist":
      case "lines":
      case "linestrips":
      case "trifans":
      case "tristrips":
        this.log("Geometry primitive type " + el.nodeName + " not supported.", ColladaLoader2.messageError);
        break;
      default:
        this._reportUnexpectedChild("library_geometries", el.nodeName);
    }
  };

  ColladaLoader2.prototype._parseSourceChild = function(source, el) {
    var child, _i, _len, _ref;
    switch (el.nodeName) {
      case "bool_array":
        source.sourceId = el.getAttribute("id");
        source.data = this._strToBools(el.textContent);
        break;
      case "float_array":
        source.sourceId = el.getAttribute("id");
        source.data = this._strToFloats(el.textContent);
        break;
      case "int_array":
        source.sourceId = el.getAttribute("id");
        source.data = this._strToInts(el.textContent);
        break;
      case "IDREF_array":
      case "Name_array":
        source.sourceId = el.getAttribute("id");
        source.data = this._strToStrings(el.textContent);
        break;
      case "technique_common":
        _ref = el.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.nodeType === 1) {
            this._parseSourceTechniqueCommonChild(source, child);
          }
        }
        break;
      default:
        this._reportUnexpectedChild("source", el.nodeName);
    }
  };

  ColladaLoader2.prototype._parseSourceTechniqueCommonChild = function(source, el) {
    var child, sourceId, _i, _len, _ref;
    switch (el.nodeName) {
      case "accessor":
        sourceId = el.getAttribute("source");
        source.count = el.getAttribute("count");
        source.stride = el.getAttribute("stride");
        if (sourceId !== "#" + source.sourceId) {
          this.log("Non-local sources not supported, source data will be empty", ColladaLoader2.messageError);
        }
        _ref = el.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.nodeType === 1) {
            this._parseTechniqueAccessorChild(source, child);
          }
        }
        break;
      default:
        this._reportUnexpectedChild("library_geometries", el.nodeName);
    }
  };

  ColladaLoader2.prototype._parseTechniqueAccessorChild = function(source, el) {
    var name, type;
    switch (el.nodeName) {
      case "param":
        name = el.getAttribute("name");
        type = el.getAttribute("type");
        source.params[name] = type;
        break;
      default:
        this._reportUnexpectedChild("accessor", el.nodeName);
    }
  };

  ColladaLoader2.prototype._createInput = function(el) {
    var input, offset, set;
    input = new ColladaInput;
    input.semantic = el.getAttribute("semantic");
    input.source = new ColladaUrlLink(el.getAttribute("source"));
    offset = el.getAttribute("offset");
    if (offset != null) {
      input.offset = parseInt(offset);
    }
    set = el.getAttribute("set");
    if (set != null) {
      input.set = parseInt(set);
    }
    return input;
  };

  ColladaLoader2.prototype._parseVerticesChild = function(geometry, el) {
    var input;
    switch (el.nodeName) {
      case "input":
        input = this._createInput(el);
        geometry.vertices[input.semantic] = input;
        break;
      default:
        this._reportUnexpectedChild("vertices", el.nodeName);
    }
  };

  ColladaLoader2.prototype._parseTrianglesChild = function(geometry, el) {
    var input;
    switch (el.nodeName) {
      case "input":
        input = this._createInput(el);
        geometry.triangles[input.semantic] = input;
        break;
      case "p":
        geometry.indices = this._strToInts(el.textContent);
        break;
      default:
        this._reportUnexpectedChild("vertices", el.nodeName);
    }
  };

  ColladaLoader2.prototype._parseLibImageChild = function(el) {
    var child, image, _i, _len, _ref;
    switch (el.nodeName) {
      case "image":
        image = new ColladaImage;
        image.id = el.getAttribute("id");
        this._addUrlTarget(image, "libImages");
        _ref = el.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.nodeType === 1) {
            this._parseImageChild(image, child);
          }
        }
        break;
      default:
        this._reportUnexpectedChild("library_images", el.nodeName);
    }
  };

  ColladaLoader2.prototype._parseImageChild = function(image, el) {
    switch (el.nodeName) {
      case "init_from":
        image.init_from = el.textContent;
        break;
      default:
        this._reportUnexpectedChild("image", el.nodeName);
    }
  };

  ColladaLoader2.prototype._getUpConversion = function(axisSrc, axisDest) {
    var _ref, _ref1, _ref2;
    if (!this.options.convertUpAxis || axisSrc === axisDest) {
      return null;
    } else {
      switch (axisSrc) {
        case "X":
          return (_ref = axisDest === "Y") != null ? _ref : {
            "XtoY": "XtoZ"
          };
        case "Y":
          return (_ref1 = axisDest === "X") != null ? _ref1 : {
            "YtoX": "YtoZ"
          };
        case "Z":
          return (_ref2 = axisDest === "X") != null ? _ref2 : {
            "ZtoX": "ZtoY"
          };
      }
    }
  };

  ColladaLoader2.prototype._addUrlTarget = function(object, lib) {
    var id;
    id = object.id;
    if (!(id != null)) {
      this.log("Object has no ID.", ColladaLoader2.messageError);
      return;
    }
    if (this.file.dae.ids[id] != null) {
      this.log("There is already an object with ID " + id + ".", ColladaLoader2.messageError);
      return;
    }
    this.file.dae.ids[id] = object;
    if (lib != null) {
      return this.file.dae[lib][id] = object;
    }
  };

  ColladaLoader2.prototype._addFxTarget = function(object, scope) {
    var sid;
    sid = object.sid;
    if (!(sid != null)) {
      this.log("Object has no SID.", ColladaLoader2.messageError);
      return;
    }
    if (scope.sids[sid] != null) {
      this.log("There is already an FX target with SID " + sid + ".", ColladaLoader2.messageError);
      return;
    }
    return scope.sids[sid] = object;
  };

  ColladaLoader2.prototype._getLinkTarget = function(link) {
    if (!(link.object != null)) {
      link.resolve(this.file, this.log);
    }
    return link.object;
  };

  ColladaLoader2.prototype._strToStrings = function(str) {
    var trimmed;
    if (str.length > 0) {
      trimmed = str.trim();
      return trimmed.split(/\s+/);
    } else {
      return [];
    }
  };

  ColladaLoader2.prototype._strToFloats = function(str) {
    var data, i, string, strings, _i, _len;
    strings = this._strToStrings(str);
    data = new Array(strings.length);
    for (i = _i = 0, _len = strings.length; _i < _len; i = ++_i) {
      string = strings[i];
      data[i] = parseFloat(string);
    }
    return data;
  };

  ColladaLoader2.prototype._strToInts = function(str) {
    var data, i, string, strings, _i, _len;
    strings = this._strToStrings(str);
    data = new Array(strings.length);
    for (i = _i = 0, _len = strings.length; _i < _len; i = ++_i) {
      string = strings[i];
      data[i] = parseInt(string);
    }
    return data;
  };

  ColladaLoader2.prototype._strToBools = function(str) {
    var data, i, string, strings, _i, _len, _ref;
    strings = this._strToStrings(str);
    data = new Array(strings.length);
    for (i = _i = 0, _len = strings.length; _i < _len; i = ++_i) {
      string = strings[i];
      data[i] = (_ref = string === "true" || string === "1") != null ? _ref : {
        "true": false
      };
    }
    return data;
  };

  return ColladaLoader2;

})();
